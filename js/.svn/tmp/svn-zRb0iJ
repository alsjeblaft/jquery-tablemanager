/*
 * jQuery tablemanager plugin
 *
 * Version: 0.1
 * Author : Mathias Vonende, le-tex publishing services GmbH
 * Date :   05-04-2012
 * 
 * A plugin to toggle the visibility of rows and columns in an 
 * HTML Table. 
 * 
 * Requires clickMenu for the column selector widget:
 * http://p.sohei.org/jquery-plugins/clickmenu/
 *
 * Usage:
 * Attach a class 'tablemanager' to each table that should be managed.
 * The table must have an id attribute.
 * Attach a class 'tablemanager-collapsible' to each th that should be collapsible.
 * Put the column heads as th elements in a thead element (instead of putting them in tbody).
 *
 * $('table.tablemanager').each(function() {
 *   $.fn.tablemanager($(this), {mincols: 5});
 * });
 *
 * mincols is the minimum number of columns that the table must have 
 * for a column selector widget to be rendered.
 *
 */


(function($){
    var cssclasses = {
	collapsible    : "tablemanager-collapsible",
	noncollapsible : "tablemanager-non-collapsible",
	row_collapse : "tablemanager-row",
	img_widget   : "tablemanager-selector-widget",
	col_collapse : "",
	col_extended : "",
	row_collapse : "",
	row_extended : "",
    };
    
    $.fn.tablemanager = function(method, args){
		method_dispatcher(method, args);
    };	
    
  function method_dispatcher(method, args){
    if (methods[method]) {
      return methods[method].apply(this, args);
    }
    else if(typeof method === 'object' || ! method ){
      return methods.init.call(this, method, args);
    }
    else {
      $.error( 'Method: ' +  method + ' does not exist on jQuery.tablemanager');
    }
  };
    
  var methods = {
    init : function(t, args){
      /*
       * $.fn.tablemanager()
       * 
       * the init method. 
       *
       * Normalize the table (= dissolve colspans and rowspans). The normalized 
       * version will be stored in table.data('colrefs'). This is an array
       * that stores, for each elementary cell of the normalized table, a
       * reference to the cell element (jQuery object representing th or td)
       * that covers this elementary cell. We speak of the "physical grid".
       * Example. Consider this 4x3 table:
       * +--++
       * +++++
       * | |++
       * +++++
       * The cell starting in (0,0) has a colspan of 3.
       * The cell starting in (0,1) has a colspan of 2 and a rowspan of 2.
       * table.data('colrefs') will be an array of length 12 that will 
       * store the physical grid coverage row-wise. So the array positions
       * 0, 1, and 2 will hold a reference to the (0,0) cell with colspan 3,
       * position 3 will refer to the second HTML cell in the first tr,
       * positions 4, 5, 8, and 9 will refer to the first HTML cell in the 
       * second tr, etc. 
       * The table width will be known after the first tr and its colspans
       * have been processed. (We are not considering pathological tables
       * whose physical width varies from row to row.)
       * There is an accessor function to get the cellref for each physical
       * position (x,y): arrpos(x,y,w) will simply calculate the array index.
       * So in order to ask: which HTML cell covers the last physical cell
       * (3,2) of the table above, you use 
       * table.data('colrefs')[arrpos(3,2,table.data('width'))]
       * 
       * A second, sparse array of all cell origins is available:
       * table.data('origins')[arrpos(0,1,table.data('width'))] => 1st cell in 2nd tr
       * table.data('origins')[arrpos(1,1,table.data('width'))] => undefined (colspanned area)
       * This is because when iterating over the physical grid, in order to
       * retrieve all cells that cover a rectangle, multiple instances of
       * a single cell would be returned. jQuery.unique() doesn't seem to 
       * reduce the rectangle to a set of unique cells, so we store 
       * table.data('origins') in addition to table.data('cellrefs').
       *
       * What else is happening during initialization?
       *
       * Render a collapse/expand icon ([+]/[-]) in each thead th 
       * with the css class 'tablemanager-collapsible'.
       * onclick event for this icon: $.fn.tablemanager('toggle_col');
       * 
       * Render a collapse/expand icon in each tbody th 
       * with the css class 'tablemanager-collapsible'.
       * onclick event for this icon: $.fn.tablemanager('toggle_row');
       *
       * Use clickMenu to create a separate widget for toggling the columns.
       * An optional integer argument, mincols, specifies the minimum number of 
       * columns for the column toggler widget to be created.
       */
      
      table = $(t);
      
      init_cellspace(table);

      if (args.mincols == undefined || args.mincols <= table.data('width')) {
        render_head_list(table);
        $('#' + table.attr('id') + '_colsList').clickMenu();
      }

      // Add toggle icons:
      table.find("th." + cssclasses.collapsible).each(function(){
        $(this).prepend('<img class="' + cssclasses.img_widget + '" src="img/expanded.png" />')
      });
      
      // Remove the toggle icons at the intersection of the column and row heads:
      var co = table.data('origins'), w = table.data('width'), hw = table.data('headwidth'), hh = table.data('headheight');
      for (x = 0; x < hw; x++) {
        for (y = 0; y < hh; y++) {
          var cell = co[arrpos(x, y,w)];
          if (cell != undefined) cell.children("img." + cssclasses.img_widget).remove();
        }
      }

      table.find("thead th." + cssclasses.collapsible + " img." + cssclasses.img_widget).click(function(){
        $.fn.tablemanager('toggle_col', $(this).parent("td,th"));
      });
      
      table.find("tbody th." + cssclasses.collapsible + " img." + cssclasses.img_widget).click(function(){
        $.fn.tablemanager('toggle_row', $(this).parent("th,td"));
      });

      return this;
    },
    toggle_col : function(cl){
      /*
       * $.fn.tablemanager('toggle_col')
       * 
       * a method to toggle a single col and all additional rows
       * inherited by the cells' colspans
       */
      var cell = $(cl);
      var colspan = cell.attr("colspan");
      
      var tablebody = cell.parents("table").find("tbody");
      var tablehead = cell.parents("table").find("thead");
      
      var rowindex = cell.data("rowspace");
      var index = cell.data("colspace");
      
      tablehead.find("tr th").each(function(){
        $this = $(this);
        if($this.data("rowspace") == rowindex){
          if($this.data("colspace") >= index && 
             $this.data("colspace") < index + colspan){
            if(!$this.hasClass("col-nonvisible")){
              hide_cell($this);
              $this.parent().nextAll("tr").find("th").each(function(){
                $this = $(this);
                if($this.data("colspace") >= index && 
                   $this.data("colspace") < index + colspan){
                  hide_cell($this);
                  $this.children("*").hide();
                  if ($this.data("applied_li") != undefined){
                    hide_li($this.data("applied_li"));
                    $this.data("applied_li").children("img").css("visibility", "hidden");
                  }
                }
              });
              hide_col(tablebody, index, colspan);
            } else {
              show_cell($this);
              $this.parent().nextAll("tr").find("th").each(function(){
                $this = $(this);
                if($this.data("colspace") >= index && 
                   $this.data("colspace") < index + colspan){
                  show_cell($this);
                  $this.children("*").show();
                  if ($this.data("applied_li") != undefined){
                    show_li($this.data("applied_li"));
                    $this.data("applied_li").children("img").css("visibility", "visible");
                  }
                }
              });
              show_col(tablebody, index, colspan);
            }
          }
        }
      });
	    
	    toggle_li(cell.data("applied_li"));
	    
	    return this;
	},
	toggle_row : function(cell){
	    /*
	     * $.fn.tablemanager('toggle_row')
	     * 
	     * a method to toggle a row and all additional rows 
	     * or inherited by the cell-rows' rowspans
	     */
	    var context_row = cell.parent();
	    
	    var rowspan  = cell.attr("rowspan");
	    var rowindex = cell.data("rowspace");
	    var colindex = cell.data("colspace");
	    
	    var context_class = context_row.next().children("th").attr("class");
	    console.log("call: toggle_row");
	    console.log(cell);
	    
	    
	    if(rowspan == 1){
		if(context_class!=undefined){
		    if(context_class.indexOf(cssclasses.collapsible) == -1){
			tabmanager_toggle_row(context_row, colindex);
			do{
			    context_row = context_row.next();
			    context_class = context_row.next().children("th").attr("class");
			    tabmanager_toggle_row_inherited(context_row, colindex);
			}while(context_class != undefined && context_class.indexOf(cssclasses.collapsible) == -1);
		    }
		    else{
			tabmanager_toggle_row(context_row, colindex);
		    }
		}
		else{
		    tabmanager_toggle_row(context_row, colindex);
		}
	    }
 	    else{
		rows_by_rowspan = cell.parent().nextAll().andSelf().slice(0, rowspan);
		
		rows_by_rowspan.each(function(){
		    context_row = $(this);
		    context_class = $(this).children("th").attr("class");
		    
		    if(context_class!=undefined && context_class.indexOf(cssclasses.collapsible) != -1){
			$.fn.tablemanager('toggle_row', context_row.children("th:last"));
			
		    }
		});
	    }
	    return this;
	},
    };
    
    function order_to_json_vert(json_head, json_temp, colnum){
	for (elem in json_head){
	    if(json_temp.colspace >= json_head[elem].colspace && 
	       json_temp.colspace < json_head[elem].colspace + json_head[elem].colspan){
		if(json_temp.rowspace == json_head[elem].rowspace + 1){
		    json_head[elem].list[colnum] = json_temp;
		}
		else{
		    //order_to_json_vert({colnum:json_head[elem].list[colnum - 1]}, json_temp, colnum);
		}
	    }
	}
    }
  };
    
  function get_next_collapsible_physrow(table, col, row) {
    var w = table.data('width');
    var h = table.data('height');
    var co = table.data('origins');
    y = row + co[arrpos(col, row, w)].attr('rowspan');
    while (y < h) {
      if (co[arrpos(col, y, w)].attr('class').indexOf(cssclasses.collapsible) >= 0) {
        return y - 1;
      }
      y++;
    }
    
    function get_json_length(json_object){
	var ctr = 0;
	for(obj in json_object)
	    ctr ++;
	return ctr;
    }
    function html_list_from_json(json_list, tabid, mode, nesting_level){
	var ul;
	if(mode === "cols"){
	    ul = $('<ul id="' + 'tmanager-list-' + tabid + '" class="tablemanager-cols-list"></ul>');
	}
	else {
	    $.error('html_list_from_json: no mode defined');
	    return;
	}
	
	for (elem in json_list){
	    var li = $('<li>' + json_list[elem].applied_cell.get(0).innerHTML + "</li>");
	    
	    li.prepend('<img style="display:inline; padding: 5px; list-style:none;" src="img/expanded.png" />');
	    
	    li.children("p, span").each(function(){
		$(this).css("display","inline");
	    });
	    
	    li.data("colspace", json_list[elem].colspace);
	    li.data("rowspace", json_list[elem].rowspace);
	    
	    var applied_cell = json_list[elem].applied_cell;
	    
	    applied_cell.data("applied_li", li);
	    li.children("img").data("applied_cell", applied_cell);
	    
	    if(mode === "cols"){
		li.children("img").click(function(){
		    $.fn.tablemanager('toggle_col', $(this).data().applied_cell);
		});
	    }
	    else if(mode === "rows"){
		li.children("img").click(function(){
		    $.fn.tablemanager('toggle_row', $(this).data().applied_cell);
		});
	    }
	    
	    if (get_json_length(json_list[elem].list) > 0){
		nested_list = html_list_from_json(json_list[elem].list, tabid, mode, nesting_level + 1);
		li.append(nested_list);
	    }
	    ul.append(li);
	}

	return ul;
    }
    
    function render_head_list(table){
	var json_head = tablehead_to_json(table.find("thead"));
	var html_list = html_list_from_json(json_head, table.attr("id"), "cols", 0);
	table.parent("div").prepend(html_list);
    }
    
    function mapreduce(array, fctn_map, fctn_reduce, init_reduce){
	maparray = $.map(array, fctn_map);
	return maparray.reduce(fctn_reduce, init_reduce);
    }
        
    function get_accumulated_colspan(cell){
			function map(cell){return $(cell).attr("colspan")}; 
			function reduce(a, b){return a + b};
			
			colarray = $.makeArray(cell.prevAll("th, td"));
			
			return mapreduce(colarray, map, reduce, 0);
    }
    
    function arrpos(x, y, w) {
      return y * w + x;
    }

  function get_rect_cells_except_origin(table, col1, row1, col2, row2) {
    var out = [];
    var w = table.data('width');
    var co = table.data('origins');
    for (var x = col1; x <= col2; x++) {
      for (var y = row1; y <= row2; y++) {
        var ap = arrpos(x, y, w);
        var cell = co[ap];
        if (cell != undefined) {
          out.push(cell);
        }
      }
    }
    out.shift(); // do not include cell at rectangle's origin 
    return $(out);
  }

  function render_head_list(table){
    var firsthead = table.data('cellrefs')[0];
    var table_id = table.attr('id');
    var ul = $('<ul id="' + table_id + '_colsList"></ul>');
    var li = $('<li><img src="img/selectcol.png" alt="select columns" title="select columns"/></li>');
    li.append(listify_head_row(table, table.data('headwidth'), table.data('width') - 1, 0));
    ul.append(li);
    firsthead.prepend(ul);
    
    var helptext = $( "<div class='tablemanager-helptext'><span class='helptext'>In the following table, click on <img src='img/collapsed.png'/>/<img src='img/expanded.png'/> to hide/display columns/rows or on <img src='img/selectcol.png'/> for a compact column toggler.</span></div>").show();
    helptext.find("span").css("background-color", firsthead.css("background-color"));
    var ok = $('<input type="button" id="' + table_id + '_gotit" value="Ok, got it!"/>');
    $(helptext).children("span:last").append(ok);
    ok.click(function(){
      $(".tablemanager-helptext").hide();
    });
    $( helptext ).insertBefore( table );
  }

  function listify_head_row(table, xstart, xend, ystart) {
    var ul = $('<ul class="tablemanager-cols-list"></ul>');
    var w = table.data('width');
    var headheight = table.data('headheight');
    var co = table.data('origins');
    var group_starts = [];
    var found = false;
    var i = 0;
    for (var y = ystart; ! found && y < headheight; y++) {
      // collect the collapsible headings in this phyiscal row 
      // (if there aren't any (b/c of rowspans), y will be incremented
      //  and the next physrow will be scanned):
      for (var x = xstart; x <= xend; x++) {
        var cell = co[arrpos(x, y,w)];
        if (cell != undefined) {
          found = true;
          group_starts[i] = cell;
          i++;
        }
      }
	
      for (var y = 1; y < rows.length; y++) {
        var cellcounter = 0;
        for(var j = 0; j < w; j++) {
          if (mr[arrpos(j, y - 1, w)] > 0) {
            var ap = arrpos(j, y, w);
            var ap1 = arrpos(j, y - 1, w);
            cr[ap] = cr[ap1];
            mr[ap] = Math.max(0, mr[ap1] - 1);
          } else {
            var cell = $(rows[y]).children("*:nth-child(" + (cellcounter + 1) + ")");
            var cs = cell.attr('colspan');
            var rs1 = cell.attr('rowspan') - 1;
            for(var i = j; i < j + cs; i++) {
              var ap = arrpos(i, y, w);
              cr[ap] = cell;
              mr[ap] = rs1;
              set_coords(cell, i, y);
            }
            j = j + cs - 1; // - 1 here because it will be incremented after the loop anyway
            cellcounter++;

            cell.click(function(){
                         console.log($(this).data("colspace") + ',' + $(this).data("rowspace"));    
                       });

          }
        }
        // recursively add lists of subordinate headings:
        if (y < headheight - 1) {
          li.append(listify_head_row(table, new_xstart, new_xend, y + 1));
        }
        ul.append(li);
      }
    }
    return ul;
  }

  function arrpos(x, y, w) {
    return y * w + x;
  }

  function set_coords(cell, x, y) {
    if (cell.data('colspace') == undefined) {
      cell.data('colspace', x);
      cell.data('rowspace', y);
    }
  }

  // initialize physical grid, FORTRAN style:
  function init_cellspace(table) {
    
    function toggle_li(listitem){
	if (listitem.hasClass("visible"))
	    hide_li(listitem);
	else
	    show_li(listitem);
    }
    if (inHead) { hd.height = 1; }

    for (var y = 1; y < rows.length; y++) {
      var cellcounter = 0;
      for(var j = 0; j < w; j++) {
        if (mr[arrpos(j, y - 1, w)] > 0) {
          var ap = arrpos(j, y, w);
          var ap1 = arrpos(j, y - 1, w);
          cr[ap] = cr[ap1];
          mr[ap] = Math.max(0, mr[ap1] - 1);
        } else {
          var cell = $(rows[y]).children("*:nth-child(" + (cellcounter + 1) + ")");
          inHead = $(rows[y]).parent("thead").length == 1;
          if (cell[0] != undefined) {
            var type = cell[0].localName;
          } else {
            console.log("No cell #" + (cellcounter + 1) + " at row " + (y + 1) +"?");
          }
          var cs = cell.attr('colspan');
          var rs1 = cell.attr('rowspan') - 1;
          var ap = arrpos(j, y, w);
          co[ap] = cell;
          cell.data('x-origin', j);
          cell.data('y-origin', y);
          for(var i = j; i < j + cs; i++) {
            ap = arrpos(i, y, w);
            cr[ap] = cell;
            mr[ap] = rs1;
            set_coords(cell, i, y);
          }
          j = j + cs - 1; // - 1 here because it will be incremented after the loop anyway
          if (! inHead && type == 'th') { hd.width = Math.max(hd.width, j + 1); }
          cellcounter++;
        }
      }
      if (inHead) { hd.height = hd.height + 1; }
    }
    
    table.data('width', w);
    table.data('height', y);
    table.data('headwidth', hd.width);
    table.data('headheight', hd.height);
    table.data('cellrefs', cr);
    table.data('origins', co);
    return cr;
  }
    
  function toggle_li(listitem){
    if (listitem.hasClass("visible")){
      hide_li(listitem);
      //listitem.removeClass("visible").addClass("nonvisible");
      //listitem.children("img").attr("src", "img/collapsed.png");
      //listitem.children("p, span").css("color","#ccc");
    } else {
      show_li(listitem);
      //listitem.removeClass("nonvisible").addClass("visible");
      //listitem.children("img").attr("src", "img/expanded.png");
      //listitem.children("p, span").css("color","#000");
    }
  }
  
  function show_li(listitem){
    listitem.removeClass("nonvisible").addClass("visible");
    listitem.children("img").attr("src", "img/expanded.png");
    listitem.children("ul").show();
    //  listitem.children("p, span").css("color","#000");
  }
  
  function hide_li(listitem){
    listitem.removeClass("visible").addClass("nonvisible");
    listitem.children("img").attr("src", "img/collapsed.png");
    listitem.children("ul").hide();
    //  listitem.children("p, span").css("color","#ccc");
  }

  function hide_col(tbody, index, colspan){
    tbody.find("td").each(function(){
    if($(this).data("colspace") >= index && 
       $(this).data("colspace") < index + colspan){
      hide_cell($(this));
    } 
    });
  }

  function show_col(tbody, index, colspan){
    tbody.find("td").each(function(){
      if($(this).data("colspace") >= index && $(this).data("colspace") < index + colspan){
        show_cell($(this));
      }
    });
  }

  function collapsed(cell) {
    img = cell.find("img." + cssclasses.img_widget);
    if (img.attr("src") == "img/collapsed.png") {
      img.attr("src", "img/expanded.png");
      return true;
    } else {
      img.attr("src", "img/collapsed.png");
      return false;
    }
  };      
  
  function toggle_cell(cell){
    if (cell.find("img." + cssclasses.img_widget).attr("src", "img/collapsed.png")) {
      show_cell(cell);
    } else {
      hide_cell(cell);
    }
  };

  function hide_cell(col){
    if(col.is("th")){
      col.find("img." + cssclasses.img_widget).attr("src", "img/collapsed.png");
    } 
    col.addClass("col-nonvisible").removeClass("col-visible").removeClass("visible");
    //  col.children("p").addClass("nonvisible").removeClass("visible");
    col.children("p").hide();
  };
  
  function show_cell(col){
    if(col.is("th")){
      col.find("img." + cssclasses.img_widget).attr("src", "img/expanded.png");
    }
    
    function tabmanager_toggle_row(row, colindex){
	if(row.hasClass("tablemanager-collapsed")){
	    row.removeClass("tablemanager-collapsed").addClass("tablemanager-expanded");
	    row.find("th img[class='tablemanager-selector-widget']").attr("src", "img/expanded.png");
	    show_row(row, colindex);
	}
	else if(row.hasClass("tablemanager-expanded")){
	    row.removeClass("tablemanager-expanded").addClass("tablemanager-collapsed");
	    row.find("th img[class='tablemanager-selector-widget']").attr("src", "img/collapsed.png");
	    hide_row(row, colindex);
	}
	else if (!row.hasClass("tablemanager-expanded") &&
		 !row.hasClass("tablemanager-collapsed")){
	    row.addClass("tablemanager-collapsed");
	    row.find("th img[class='tablemanager-selector-widget']").attr("src", "img/collapsed.png");
	    hide_row(row, colindex);
	}
    };
    function tabmanager_toggle_row_inherited(row, colindex){
	if(row.hasClass("tablemanager-inherit-collapsed")){
	    row.removeClass("tablemanager-inherit-collapsed").addClass("tablemanager-inherit-expanded");
	    show_row(row, colindex);
	}
	else if(row.hasClass("tablemanager-inherit-expanded")){
	    row.removeClass("tablemanager-inherit-expanded").addClass("tablemanager-inherit-collapsed");
	    hide_row(row, colindex);
	}
	else{
	    row.addClass("tablemanager-inherit-collapsed");
	    hide_row(row, colindex);
	}
    };
})(jQuery);
